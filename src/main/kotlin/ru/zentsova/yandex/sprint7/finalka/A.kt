package ru.zentsova.yandex.sprint7.finalka

/*
-- Спринт 7. Финалка. A. Расстояние по Левенштейну --
Ссылка на удачную посылку: https://contest.yandex.ru/contest/25597/run-report/137903977/

-- ПРИНЦИП РАБОТЫ --

dp[i][j] - минимальное число операций, которые необходимы,
чтобы превратить первые i символов строки s в первые j символов строки t.

dp[i][0] = i (dp[0][j] = j) - заполнение базовых случаев,
чтобы из первых i символов s получить пустую строку, нужно удалить i символов
(чтобы из пустой строки получить первые j символов t, нужно вставить j символов)

Заполняем остальное:
- если символы совпадают, ничего не делаем.
- иначе берем минимум из - удаления, вставки, замены.

Возвращаем последнее значение в матрице - оно и будет ответом.


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

База:
- пустую строку можно получить из другой с помощью только вставок или удалений (это dp[0][j] = j и dp[i][0] = i).

Переход: для каждой пары префиксов строк мы минимизируем число операций:
- если символы совпадают → не увеличиваем стоимость;
- иначе выбираем минимум из трёх возможных предыдущих состояний (удаление, вставка, замена), добавляя 1 операцию.

Оптимальность:
- на каждом шаге выбирается минимальное число операций, значит, итоговое решение минимально.

Таким образом, dp[n][m] содержит минимальное число изменений, необходимых для преобразования одной строки в другую.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(nm) - где n - длина строки s, m - длина строки t.


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(nm) - где n - длина строки s, m - длина строки t (хранение матрицы dp)

*/

fun main() {
	val s = readln()
	val t = readln()
	println(levenshteinDistance(s, t))
}

fun levenshteinDistance(s: String, t: String): Int {
	val n = s.length
	val m = t.length

	val dp = Array(n + 1) { IntArray(m + 1) }

	for (i in 0..n) dp[i][0] = i
	for (j in 0..m) dp[0][j] = j

	for (i in 1..n) {
		for (j in 1..m) {
			val cost = if (s[i - 1] == t[j - 1]) 0 else 1

			dp[i][j] = minOf(
				dp[i - 1][j] + 1,
				dp[i][j - 1] + 1,
				dp[i - 1][j - 1] + cost
			)
		}
	}

	return dp[n][m]
}