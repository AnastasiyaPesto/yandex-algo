package ru.zentsova.yandex.sprint7.finalka

/*
-- Спринт 7. Финалка. A. Расстояние по Левенштейну --
Ссылка на удачную посылку: https://contest.yandex.ru/contest/25597/run-report/138008677/

-- ПРИНЦИП РАБОТЫ --

1. Что будет храниться в массиве dp?

dp[i][j] - минимальное число операций, которые необходимы,
чтобы префикс строки s длины i s в префикс строки t длины j.

2. Каким будет базовый случай для задачи?

dp[i][0] = i (dp[0][j] = j) - заполнение базовых случаев,
чтобы из первых i символов s получить пустую строку, нужно удалить i символов
(чтобы из пустой строки получить первые j символов t, нужно вставить j символов)

3. Каким будет переход динамики?

Заполняем остальное:
- если символы совпадают, ничего не делаем
(то есть cost = 0. Нам не нужно делать ни вставку, ни удаление, ни замены.
Формально да, но мы сохраняем в dp[i][j] для построения таблицы)

- иначе берем минимум из - удаления, вставки, замены.

4. Каким будет порядок вычисления данных в массиве dp?

Таблица dp заполняется снизу вверх, слева направо.
Сначала заполняются базовые случаи.
Затем — все dp[i][j] по возрастанию i и j.

5. Где будет располагаться ответ на исходный вопрос?

dp[n][m] — минимальное количество операций, чтобы превратить всю строку s длиной n в строку t длиной m.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

База:
- пустую строку можно получить из другой с помощью только вставок или удалений (это dp[0][j] = j и dp[i][0] = i).

Переход: для каждой пары префиксов строк мы минимизируем число операций:
- если символы совпадают -> не увеличиваем стоимость;
- иначе выбираем минимум из трёх возможных предыдущих состояний (удаление, вставка, замена), добавляя 1 операцию.

Оптимальность:
- на каждом шаге выбирается минимальное число операций, значит, итоговое решение минимально.

Таким образом, dp[n][m] содержит минимальное число изменений, необходимых для преобразования одной строки в другую.


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(nm) - где n - длина строки s, m - длина строки t.


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(m) - где m - длина строки t
(на каждом шаге мы используем только текущую и предыдущую строку из dp => их можно перезаписывать)

*/

fun main() {
	val s = readln()
	val t = readln()
	println(levenshteinDistance(s, t))
}

fun levenshteinDistance(s: String, t: String): Int {
	val n = s.length
	val m = t.length

	var previousString = IntArray(m + 1) { it }
	var currentString = IntArray(m + 1)

	for (i in 1..n) {
		currentString[0] = i
		for (j in 1..m) {
			val cost = if (s[i - 1] == t[j - 1]) 0 else 1

			val deletion = previousString[j] + 1
			val insertion = currentString[j - 1] + 1
			val substitution = previousString[j - 1] + cost

			currentString[j] = minOf(deletion, insertion, substitution)
		}
		val temp = previousString
		previousString = currentString
		currentString = temp
	}

	return previousString.last()
}